package {{.Pkg}}

import (
  "context"
  "strings"
  "time"
  "github.com/metauro/gomodel"
  "database/sql"
)

var _ = time.Second

{{range .Fields -}}
const {{$.TitleName}}Field{{.TitleName}} = "{{.SQLName}}"
{{end}}
var {{.TitleName}}Fields = []string{
{{range .Fields}}  {{$.TitleName}}Field{{.TitleName}},
{{end -}}
}

type {{.TitleName}} struct {
{{range .Fields}}  {{.TitleName}} {{.Type}} `{{.Tag}}`
{{end -}}
}

{{$repo := (print .CamelName "Repo" ) -}}
{{- $selectRepo := (print "select" .TitleName "Repo") -}}
{{- $insertRepo := (print "insert" .TitleName "Repo") -}}
{{- $updateRepo := (print "update" .TitleName "Repo") -}}
{{- $duplicateRepo := (print "duplicate" .TitleName "Repo") -}}
{{- $deleteRepo := (print "delete" .TitleName "Repo") -}}
{{- $fields := "" -}}
{{- range $i, $field := .Fields -}}
{{if $i}}
{{$fields = (print $fields ",")}}
{{end}}
{{$fields = (print $fields $field.SQLName)}}
{{- end -}}

type {{$repo}} struct {
	db gomodel.Execer
}

func New{{.TitleName}}Repo (db gomodel.Execer) *{{$repo}} {
  return &{{$repo}} {
    db: db,
  }
}

type {{$insertRepo}} struct {
  db gomodel.Execer
  sqlBuilder strings.Builder
  bindings []interface{}
}

type {{$duplicateRepo}} struct {
  db gomodel.Execer
  first bool
  sqlBuilder strings.Builder
  bindings []interface{}
}

type {{$updateRepo}} struct {
  db gomodel.Execer
  hasOrderBy bool
  hasWhere   bool
  whereCond  string
  first bool
  sqlBuilder strings.Builder
  bindings []interface{}
}

type {{$selectRepo}} struct {
  db gomodel.Execer
  hasOrderBy bool
  hasWhere   bool
  whereCond  string
  fields     []string
  sqlBuilder strings.Builder
  bindings []interface{}
}

type {{$deleteRepo}} struct {
  db gomodel.Execer
  hasOrderBy bool
  hasWhere   bool
  whereCond  string
  sqlBuilder strings.Builder
  bindings []interface{}
}

func (r *{{$repo}}) Select() *{{$selectRepo}} {
	res := &{{$selectRepo}}{
	  db: r.db,
		fields: {{.TitleName}}Fields,
	}
	res.sqlBuilder.WriteString("SELECT {{$fields}} FROM {{.SQLName}} ")
	return res
}

func (r *{{$repo}}) SelectDistinct() *{{$selectRepo}} {
	res := &{{$selectRepo}}{
		db: r.db,
		fields: {{.TitleName}}Fields,
	}
	res.sqlBuilder.WriteString("SELECT DISTINCT {{$fields}} FROM {{.SQLName}} ")
	return res
}

func (r *{{$repo}}) SelectPick(fields ...string) *{{$selectRepo}} {
  res := &{{$selectRepo}}{
		db: r.db,
		fields: fields,
	}
	res.sqlBuilder.WriteString("SELECT ")
	for i, l := 0, len(fields) - 1; i < l; i++ {
    res.sqlBuilder.WriteString(fields[i])
    res.sqlBuilder.WriteString(",")
	}
	res.sqlBuilder.WriteString(fields[len(fields) - 1])
	res.sqlBuilder.WriteString(" FROM {{.SQLName}} ")
	return res
}

func (r *{{$repo}}) SelectDistinctPick(fields ...string) *{{$selectRepo}} {
  res := &{{$selectRepo}}{
    db: r.db,
    fields: fields,
  }
	res.sqlBuilder.WriteString("SELECT DISTINCT ")
	for i, l := 0, len(fields) - 1; i < l; i++ {
    res.sqlBuilder.WriteString(fields[i])
    res.sqlBuilder.WriteString(",")
	}
	res.sqlBuilder.WriteString(fields[len(fields) - 1])
	res.sqlBuilder.WriteString(" FROM {{.SQLName}} ")
	return res
}

func (r *{{$repo}}) SelectOmit(fields ...string) *{{$selectRepo}} {
  size := len(fields)
omit:
  for _, field := range {{.TitleName}}Fields {
    for _, omitField := range fields {
      if field == omitField {
        continue omit
      }
    }
    fields = append(fields, field)
  }
  fields = fields[size:]
  res := &{{$selectRepo}}{
      db: r.db,
      fields: fields,
  }
  res.sqlBuilder.WriteString("SELECT ")
  for i, l := 0, len(fields) - 1; i < l; i++ {
    res.sqlBuilder.WriteString(fields[i])
    res.sqlBuilder.WriteString(",")
  }
  res.sqlBuilder.WriteString(fields[len(fields) - 1])
  res.sqlBuilder.WriteString(" FROM {{.SQLName}} ")
  return res
}

func (r *{{$repo}}) SelectDistinctOmit(fields ...string) *{{$selectRepo}} {
  size := len(fields)
omit:
  for _, field := range {{.TitleName}}Fields {
    for _, omitField := range fields {
      if field == omitField {
        continue omit
      }
    }
    fields = append(fields, field)
  }
  fields = fields[size:]
  res := &{{$selectRepo}}{
  		db: r.db,
  		fields: fields,
  }
  res.sqlBuilder.WriteString("SELECT DISTINCT ")
  for i, l := 0, len(fields) - 1; i < l; i++ {
    res.sqlBuilder.WriteString(fields[i])
    res.sqlBuilder.WriteString(",")
  }
  res.sqlBuilder.WriteString(fields[len(fields) - 1])
  res.sqlBuilder.WriteString(" FROM {{.SQLName}} ")
	return res
}

func (r *{{$repo}}) Insert({{.CamelName}}List ...*{{.TitleName}}) *{{$insertRepo}} {
  res :=  &{{$insertRepo}} {
    db: r.db,
  }
  res.sqlBuilder.WriteString("INSERT INTO {{.SQLName}} ({{$fields}}) VALUES ")
  for i, m := range {{.CamelName}}List {
    if i > 0 {
      res.sqlBuilder.WriteString(",")
    }
    res.sqlBuilder.WriteString("(")
    {{range $i, $field := .Fields -}}
      if m.{{$field.TitleName}}{{if eq $field.Type "time.Time"}}.IsZero(){{else}} == {{$field.ZeroValue}}{{end}} {
        res.sqlBuilder.WriteString("{{if $i}},{{end}}DEFAULT")
      } else {
        res.sqlBuilder.WriteString("{{if $i}},{{end}}{{$.Placeholder}}")
        res.bindings = append(res.bindings, m.{{$field.TitleName}})
      }
    {{end}}
    res.sqlBuilder.WriteString(")")
  }
  return res
}

func (r *{{$repo}}) Update() *{{$updateRepo}} {
  res := &{{$updateRepo}} {
    db: r.db,
    first: true,
  }
  res.sqlBuilder.WriteString("UPDATE {{.SQLName}} SET ")
  return res
}

{{if .SoftDeleteColumn}}
func (r *{{$repo}}) Delete(hardDelete bool) *{{$deleteRepo}} {
  res := &{{$deleteRepo}} {
    db: r.db,
  }

  if hardDelete {
    res.sqlBuilder.WriteString("DELETE FROM {{.SQLName}} ")
  } else {
    res.sqlBuilder.WriteString("UPDATE {{.SQLName}} SET {{.SoftDeleteColumn}}=?")
    res.bindings = append(res.bindings, time.Now())
  }
  return res
}
{{else}}
func (r *{{$repo}}) Delete() *{{$deleteRepo}} {
  res := &{{$deleteRepo}} {
    db: r.db,
  }
  res.sqlBuilder.WriteString("DELETE FROM {{.SQLName}} ")
  return res
}
{{end}}

{{range $repo := newSlice $selectRepo $updateRepo $deleteRepo -}}
func (r *{{$repo}}) And() *{{$repo}} {
  r.whereCond = "AND"
  return r
}

func (r *{{$repo}}) Or() *{{$repo}} {
  r.whereCond = "OR"
  return r
}

func (r *{{$repo}}) whereCheck() {
 if r.hasWhere {
   if r.whereCond == "" {
     r.And()
   }

   r.sqlBuilder.WriteString(" ")
   r.sqlBuilder.WriteString(r.whereCond)
   return
 }

 r.hasWhere = true
 {{if $.SoftDeleteColumn -}}
 r.sqlBuilder.WriteString(" WHERE ({{$.SoftDeleteColumn}} IS NULL) AND")
 {{- else -}}
 r.sqlBuilder.WriteString(" WHERE")
 {{end -}}
}

{{range $.Fields -}}
func (r *{{$repo}}) Where{{.TitleName}}Equal({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
	r.sqlBuilder.WriteString(" {{.SQLName}}={{$.Placeholder}}")
	r.bindings = append(r.bindings, {{.CamelName}})
	return r
}

func (r *{{$repo}}) Where{{.TitleName}}NotEqual({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
	r.sqlBuilder.WriteString(" {{.SQLName}}<>{{$.Placeholder}}")
	r.bindings = append(r.bindings, {{.CamelName}})
	return r
}

func (r *{{$repo}}) Where{{.TitleName}}In({{.CamelName}}List ...{{.Type}}) *{{$repo}} {
	size := len({{.CamelName}}List)
	if size == 0 {
	  return r
	}

  r.whereCheck()
	r.sqlBuilder.WriteString(" {{.SQLName}} IN(")

	for i, l := 0, size - 1; i < l; i++ {
		r.sqlBuilder.WriteString("{{$.Placeholder}},")
		r.bindings = append(r.bindings, {{.CamelName}}List[i])
	}
	r.sqlBuilder.WriteString("{{$.Placeholder}})")
	r.bindings = append(r.bindings, {{.CamelName}}List[size - 1])
	return r
}

func (r *{{$repo}}) Where{{.TitleName}}NotIn({{.CamelName}}List ...{{.Type}}) *{{$repo}} {
	size := len({{.CamelName}}List)
	if size == 0 {
	  return r
	}

  r.whereCheck()
	r.sqlBuilder.WriteString(" {{.SQLName}} NOT IN(")

	for i, l := 0, size - 1; i < l; i++ {
		r.sqlBuilder.WriteString("{{$.Placeholder}},")
		r.bindings = append(r.bindings, {{.CamelName}}List[i])
	}
	r.sqlBuilder.WriteString("{{$.Placeholder}})")
	r.bindings = append(r.bindings, {{.CamelName}}List[size - 1])
	return r
}

func (r *{{$repo}}) Where{{.TitleName}}IsNil() *{{$repo}} {
  r.whereCheck()
	r.sqlBuilder.WriteString(" {{.SQLName}} IS NULL")
	return r
}

func (r *{{$repo}}) Where{{.TitleName}}IsNotNil() *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} IS NOT NULL")
  return r
}

func (r *{{$repo}}) Where{{.TitleName}}Raw(raw string, bindings ...interface{}) *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} ")
  r.sqlBuilder.WriteString(raw)
  r.bindings = append(r.bindings, bindings...)
  return r
}

{{if eq .Type "string"}}
func (r *{{$repo}}) Where{{.TitleName}}Like({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} LIKE {{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.CamelName}})
  return r
}

func (r *{{$repo}}) Where{{.TitleName}}NotLike({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} NOT LIKE {{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.CamelName}})
  return r
}
{{end -}}

{{if eq .Type "int" "uint" "int8" "int16" "int32" "int64" "uint8" "uint16" "uint32" "uint64" "float32" "float64"
"time.Time"}}
func (r *{{$repo}}) Where{{.TitleName}}GreatThan({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}>{{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.CamelName}})
  return r
}

func (r *{{$repo}}) Where{{.TitleName}}GreatThanEqual({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}>={{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.CamelName}})
  return r
}

func (r *{{$repo}}) Where{{.TitleName}}LessThan({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}<{{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.CamelName}})
  return r
}

func (r *{{$repo}}) Where{{.TitleName}}LessThenEqual({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.whereCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}<={{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.CamelName}})
  return r
}
{{end}}
{{end}}

func (r *{{$repo}}) orderByCheck() {
  if r.hasOrderBy {
    r.sqlBuilder.WriteString(",")
    return
  }

  r.hasOrderBy = true
  r.sqlBuilder.WriteString(" ORDER BY")
}

func (r *{{$repo}}) OrderByRaw(raw string, bindings ...interface{}) *{{$repo}} {
  r.orderByCheck()
  r.sqlBuilder.WriteString(" ")
  r.sqlBuilder.WriteString(raw)
  r.bindings = append(r.bindings, bindings...)
  return r
}

{{range $.Fields}}
func (r *{{$repo}}) OrderBy{{.TitleName}}Asc() *{{$repo}} {
  r.orderByCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} ASC")
  return r
}

func (r *{{$repo}}) OrderBy{{.TitleName}}Desc() *{{$repo}} {
  r.orderByCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} DESC")
  return r
}

func (r *{{$repo}}) OrderBy{{.TitleName}}Raw(raw string, bindings ...interface{}) *{{$repo}} {
  r.orderByCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} ")
  r.sqlBuilder.WriteString(raw)
  r.bindings = append(r.bindings, bindings...)
  return r
}
{{end}}

func (r *{{$repo}}) Limit(limit int) *{{$repo}} {
  r.sqlBuilder.WriteString(" LIMIT ?")
  r.bindings = append(r.bindings, limit)
  return r
}
{{end}}

func (r *{{$selectRepo}}) Offset(offset int) *{{$selectRepo}} {
  r.sqlBuilder.WriteString(" OFFSET ?")
  r.bindings = append(r.bindings, offset)
  return r
}

{{range $repo := newSlice $insertRepo $duplicateRepo $updateRepo $deleteRepo}}
func (r *{{$repo}}) ExecContext(ctx context.Context) (int64, error) {
  res, err := r.db.ExecContext(ctx, r.sqlBuilder.String(), r.bindings...)
  if err != nil {
    return 0, err
  }
  return {{if eq $repo $insertRepo}}res.LastInsertId(){{else}}res.RowsAffected(){{end}}
}

func (r *{{$repo}}) MustExecContext(ctx context.Context) int64 {
  res, err := r.ExecContext(ctx)
  if err != nil {
    panic(err)
  }
  return res
}

func (r *{{$repo}}) Exec() (int64, error) {
  return r.ExecContext(context.Background())
}

func (r *{{$repo}}) MustExec() int64 {
  return r.MustExecContext(context.Background())
}
{{end}}

// GetContext 获取单条数据
func (r *{{$selectRepo}}) GetContext(ctx context.Context) (*{{$.TitleName}}, error) {
  r.Limit(1)
	row := r.db.QueryRowContext(ctx, r.sqlBuilder.String(), r.bindings...)
	m := &{{$.TitleName}}{}
	scanners := make([]interface{}, len(r.fields))
	for i, field := range r.fields {
    switch field {
      {{range $field := .Fields -}}
      case "{{$field.SQLName}}":
        scanners[i] = &m.{{$field.TitleName}}
      {{end -}}
    }
	}
	return m, row.Scan(scanners...)
}

// MustGetContext 获取单条数据,如果返回 sql.ErrNoRows 错误则返回 nil, 其他错误则 panic
func (r *{{$selectRepo}}) MustGetContext(ctx context.Context) *{{$.TitleName}} {
  res, err := r.GetContext(ctx)
  if err != nil {
    if err == sql.ErrNoRows {
      return nil
    }
    panic(err)
  }
  return res
}

// MustGetOrFailContext 获取单条数据,有错误时 panic
func (r *{{$selectRepo}}) MustGetOrFailContext(ctx context.Context) *{{$.TitleName}} {
  res, err := r.GetContext(ctx)
  if err != nil {
    panic(err)
  }
  return res
}

// Get 获取单条数据
func (r *{{$selectRepo}}) Get() (*{{$.TitleName}}, error) {
  return r.GetContext(context.Background())
}

// MustGet 获取单条数据,如果返回 sql.ErrNoRows 错误则返回 nil, 其他错误则 panic
func (r *{{$selectRepo}}) MustGet() *{{$.TitleName}} {
  return r.MustGetContext(context.Background())
}

// MustGetOrFail 获取单条数据,有错误时 panic
func (r *{{$selectRepo}}) MustGetOrFail() *{{$.TitleName}} {
  return r.MustGetOrFailContext(context.Background())
}

// SelectContext 获取多条数据
func (r *{{$selectRepo}}) SelectContext(ctx context.Context) ([]*{{$.TitleName}}, error) {
	var err error
	rows, err := r.db.QueryContext(ctx, r.sqlBuilder.String(), r.bindings...)
	if err != nil {
		return nil, err
	}
	res := make([]*{{$.TitleName}}, 0)
	scanners := make([]interface{}, len(r.fields))
	defer func() {
		cerr := rows.Close()
		if err == nil {
			err = cerr
		}
	}()
	for rows.Next() {
		m := &{{$.TitleName}}{}
    for i, field := range r.fields {
      switch field {
        {{range $field := .Fields -}}
        case {{$field.SQLName}}:
          scanners[i] = &m.{{$field.TitleName}}
        {{end -}}
      }
    }
		if err := rows.Scan(scanners...); err != nil {
			return nil, err
		}
		res = append(res, m)
	}
	return res, nil
}

// MustSelectContext 获取多条数据,有错误时 panic
func (r *{{$selectRepo}}) MustSelectContext(ctx context.Context) []*{{$.TitleName}} {
  res, err := r.SelectContext(ctx)
  if err != nil {
    panic(err)
  }
  return res
}

// Select 获取多条数据
func (r *{{$selectRepo}}) Select() ([]*{{$.TitleName}}, error) {
  return r.SelectContext(context.Background())
}

// MustSelect 获取多条数据,有错误时 panic
func (r *{{$selectRepo}}) MustSelect() []*{{$.TitleName}} {
  return r.MustSelectContext(context.Background())
}

// Duplicate 用于更新插入数据时冲突的数据
func (r *{{$insertRepo}}) Duplicate() *{{$duplicateRepo}} {
  res := &{{$duplicateRepo}} {
    db: r.db,
    bindings: r.bindings,
    first: true,
  }
  res.sqlBuilder.WriteString(r.sqlBuilder.String() + " ON DUPLICATE KEY UPDATE")
  return res
}

{{range $repo := newSlice $updateRepo $duplicateRepo -}}
func (r *{{$repo}}) setCheck() {
   if r.first {
     r.first = false
     return
   }

   r.sqlBuilder.WriteString(",")
   r.first = false
}

// Set 将数据更新为 {{$.CamelName}} 内的值,零值会被忽略
func (r *{{$repo}}) Set({{$.CamelName}} *{{$.TitleName}}) *{{$repo}} {
  {{- range $i, $field := $.Fields}}
  {{$field.CamelName}} := {{$.CamelName}}.{{$field.TitleName}}
  if {{if eq $field.Type "time.Time"}}!{{$field.CamelName}}.IsZero(){{else}}{{$field.CamelName}} != {{$field.ZeroValue}}{{end}} {
    r.setCheck()
    r.sqlBuilder.WriteString(" {{$field.SQLName}}={{$.Placeholder}}")
    r.bindings = append(r.bindings, {{$field.CamelName}})
  }
  {{end}}
  return r
}

{{range $.Fields -}}
// Set{{.TitleName}} 将字段更新为指定值
func (r *{{$repo}}) Set{{.TitleName}}({{.CamelName}} {{.Type}}) *{{$repo}} {
  r.setCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}={{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.CamelName}})
  return r
}

// Set{{.TitleName}}Empty 将字段更新为零值
func (r *{{$repo}}) Set{{.TitleName}}Empty() *{{$repo}} {
  r.setCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}={{$.Placeholder}}")
  r.bindings = append(r.bindings, {{.ZeroValue}})
  return r
}

// Set{{.TitleName}}Nil 将字段更新为 nil
func (r *{{$repo}}) Set{{.TitleName}}Nil() *{{$repo}} {
  r.setCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}=NULL")
  return r
}

// Set{{.TitleName}}Raw 自定义更新语句
func (r *{{$repo}}) Set{{.TitleName}}Raw(sql string, bindings ...interface{}) *{{$repo}} {
  r.setCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}} ")
  r.sqlBuilder.WriteString(sql)
  r.bindings = append(r.bindings, bindings...)
  return r
}

{{if eq $repo $duplicateRepo}}
// Set{{.TitleName}}Values 有冲突时将值更新为插入的值
func (r *{{$repo}}) Set{{.TitleName}}Values() *{{$repo}} {
  r.setCheck()
  r.sqlBuilder.WriteString(" {{.SQLName}}=VALUES({{.SQLName}})")
  return r
}
{{end}}
{{end}}
{{end}}

{{range $repo := newSlice $selectRepo $insertRepo $duplicateRepo $updateRepo $deleteRepo}}
// SQL 输出 SQL 语句与参数
func (r *{{$repo}}) SQL() (string, []interface{}) {
  return r.sqlBuilder.String(), r.bindings
}
{{end}}
